<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>호구마츄로그</title><description>반갑습니다.
iOS 개발자 호구마츄입니다.</description><link>https://hogumachu.github.io/</link><language>ko</language><lastBuildDate>Thu, 8 Jun 2023 04:32:31 +0000</lastBuildDate><pubDate>Thu, 8 Jun 2023 04:32:31 +0000</pubDate><ttl>250</ttl><atom:link href="https://hogumachu.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://hogumachu.github.io/articles/tech_interview</guid><title>기술 면접 준비 iOS</title><description>iOS 기술 면접 예상 질문들</description><link>https://hogumachu.github.io/articles/tech_interview</link><pubDate>Wed, 17 May 2023 15:15:00 +0000</pubDate><content:encoded><![CDATA[<h3>일반</h3><p>✔️ iOS 개발자를 선택한 이유</p><p>✔️ Swift의 장점 및 단점</p><p>✔️ 저장 프로퍼티 &amp; 연산 프로퍼티</p><p>✔️ Property Observer 설명</p><p>✔️ Closure 설명</p><p>✔️ @escaping Closure 설명</p><p>✔️ @propertyWrapper 설명</p><p>✔️ Generic 설명 (왜 사용?)</p><p>✔️ 함수형 프로그래밍 설명 (순수함수, 고차함수, 일급객체)</p><p>✔️ @main 설명</p><p>✔️ Value type vs. Reference type</p><p>✔️ instace vs. class vs. static (method &amp; property)</p><p>✔️ ARC (Automatic Reference Counting) 설명</p><p>✔️ Static 설명 (왜 사용?)</p><p>✔️ Lazy 설명 (왜 사용?)</p><p>✔️ COW (Copy-On-Write) 설명</p><p>✔️ Access Level 설명 (종류마다 차이점)</p><p>✔️ final 설명</p><p>✔️ mutating 설명</p><p>✔️ class 성능 향상 방법</p><p>✔️ Stoaryboard vs. Code base</p><p>✔️ KVO 설명</p><p>✔️ Delegate vs. Notification</p><p>✔️ String을 subscript로 접근할 수 없는 이유 설명</p><p>✔️ Library &amp; Framework 설명</p><p>✔️ Static &amp; Dynamic (Library, Framework) 설명</p><p>✔️ Run Loop 설명</p><p>✔️ Bundle &amp; Package 설명</p><p>✔️ Codable 설명</p><p>✔️ App thining 설명</p><h3>Protocol</h3><p>✔️ Protocl 설명</p><p>✔️ Extension 설명 (override 가능?)</p><p>✔️ POP (Protocol Oriented Programming) 설명</p><h3>UI</h3><p>✔️ CALayer 설명</p><p>✔️ UINavigationController 역할</p><p>✔️ StackView 장단점</p><p>✔️ frame vs. bounds</p><p>✔️ Intrinsic Size 설명</p><p>✔️ hugging &amp; resistance 설명</p><p>✔️ sedNeedsLayout &amp; layoutIfNeeded &amp; layoutSubviews 설명</p><p>✔️ Drawing Cycle 설명</p><p>✔️ UIWindow 설명</p><h3>Thread</h3><p>✔️ GCD (Grand Central Dispatch) 설명</p><p>✔️ QoS (Quality of Service) 설명</p><p>✔️ Main Thread에서만 UI를 작업할 수 있는 이유</p><h3>Method Dispatch</h3><p>✔️ Method Dispatch (Static &amp; Dynamic) 설명</p><p>✔️ Existential Container 설명</p><p>✔️ Method Inlining 설명</p><p>✔️ Method Swizzling 설명</p><h3>Life Cycle</h3><p>✔️ ViewController Life Cycle 설명</p><p>✔️ App Life Cycle 설명</p><p>✔️ Scene Life Cycle 설명</p><h3>RxSwift</h3><p>✔️ RxSwift 설명</p><p>✔️ Hot Observable &amp; Cold Observable</p><p>✔️ Subject 설명</p><p>✔️ Bind vs. Drive</p><p>✔️ Traits (Single, Completable, Maybe) 설명</p>]]></content:encoded></item><item><guid isPermaLink="true">https://hogumachu.github.io/articles/arc</guid><title>ARC</title><description>Swift에서 메모리 관리를 위해 사용하는 ARC</description><link>https://hogumachu.github.io/articles/arc</link><pubDate>Tue, 16 May 2023 18:15:00 +0000</pubDate><content:encoded><![CDATA[<h1>ARC</h1><pre><code><span class="type">Automatic Reference Counting</span> - 자동 참조 카운팅
</code></pre><p>✔️ <b>Swift에서 제공하는 메모리 관리</b></p><p>✔️ <b>Reference에 대한 참조 횟수</b>를 자동으로 관리해줌</p><p>✔️ 컴파일할 때 retain/release코드를 작성해줌</p><p>✔️ 참조할 때 Reference Count를 증가시키고 참조하지 않을 때 Reference Count를 감소시킴</p><p>✔️ Reference Count가 0이 되면 메모리에서 해제함</p><h2>Strong Reference Cycle</h2><p>✔️ <b>강한 참조 사이클</b></p><p>✔️ 메모리가 해제되어야 하는 상황인데 서로 참조를 하고 있어 Reference Count가 0이 되지 않는 상황</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">class</span> Human {
    <span class="keyword">var</span> device: <span class="type">Device</span>?
    
    <span class="keyword">init</span>(device: <span class="type">Device</span>? = <span class="keyword">nil</span>) {
        <span class="keyword">self</span>.<span class="property">device</span> = device
    }
}


<span class="keyword">class</span> Device {
    <span class="keyword">var</span> owner: <span class="type">Human</span>?
    
    <span class="keyword">init</span>(owner: <span class="type">Human</span>? = <span class="keyword">nil</span>) {
        <span class="keyword">self</span>.<span class="property">owner</span> = owner
    }
}

<span class="keyword">var</span> human: <span class="type">Human</span>? = <span class="type">Human</span>() <span class="comment">// RC = 1</span>
<span class="keyword">var</span> device: <span class="type">Device</span>? = <span class="type">Device</span>() <span class="comment">// RC = 1</span>
human?.<span class="property">device</span> = device <span class="comment">// RC = 2</span>
device?.<span class="property">owner</span> = human <span class="comment">// RC = 2</span>

human = <span class="keyword">nil</span> <span class="comment">// RC = 1</span>
device = <span class="keyword">nil</span> <span class="comment">// RC = 1</span>
</code></pre><p>✔️ 예시처럼 서로가 서로를 참조하고 있을 때는 메모리에 계속 남아있음</p><p>✔️ 위와 같은 상황이 반복되면 접근할 수 없는 객체가 많아지고 메모리 부족을 야기할 수 있음</p><h2>해결 방법</h2><p>✔️ <b>미소유 참조</b> 또는 <b>약한 참조</b>를 사용하면 Reference Count를 증가시키지 않기 때문에 위의 문제를 해결할 수 있음</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">class</span> Human {
    <span class="keyword">unowned var</span> device: <span class="type">Device</span>?
    
    <span class="keyword">init</span>(device: <span class="type">Device</span>? = <span class="keyword">nil</span>) {
        <span class="keyword">self</span>.<span class="property">device</span> = device
    }
}


<span class="keyword">class</span> Device {
    <span class="keyword">weak var</span> owner: <span class="type">Human</span>?
    
    <span class="keyword">init</span>(owner: <span class="type">Human</span>? = <span class="keyword">nil</span>) {
        <span class="keyword">self</span>.<span class="property">owner</span> = owner
    }
}

<span class="keyword">var</span> human: <span class="type">Human</span>? = <span class="type">Human</span>() <span class="comment">// RC = 1</span>
<span class="keyword">var</span> device: <span class="type">Device</span>? = <span class="type">Device</span>() <span class="comment">// RC = 1</span>
human?.<span class="property">device</span> = device <span class="comment">// 변화 없음</span>
device?.<span class="property">owner</span> = human <span class="comment">// 변화 없음</span>

human = <span class="keyword">nil</span> <span class="comment">// RC = 0</span>
device = <span class="keyword">nil</span> <span class="comment">// RC = 0</span>
</code></pre><h3>unowned - 미소유 참조</h3><p>✔️ Reference Count를 증가시키지 않고 있는 그대로 값을 가져옴</p><b>장점</b><p>: 옵셔널 체이닝을 하지 않고 값을 가져올 수 있음</p><b>단점</b><p>: 만약 메모리에서 해제된 값을 참조하게 되면 앱이 강제 종료 (치명적)</p><h3>weak - 약한 참조</h3><p>✔️ Reference Count를 증가시키지 않고 Optional로 값을 가져옴</p><b>장점</b><p>: 값이 해제되었을 때 nil 로 받기 때문에 안전함</p><b>단점</b><p>: 옵셔널 체이닝을 해야 하기 때문에 코드 길이가 늘어남</p><pre><code><span class="keyword">func</span> weakMethod() {
    <span class="call">doSomething</span> { [<span class="keyword">weak self</span>] <span class="keyword">_ in
        guard let self else</span> { <span class="keyword">return</span> }
        <span class="keyword">self</span>.<span class="call">doAnything</span>()
    }
}

<span class="keyword">func</span> unownedMethod() {
    <span class="call">doSomething</span> { [<span class="keyword">unowned self</span>] <span class="keyword">_ in
        self</span>.<span class="call">doAnything</span>()
    }
}
</code></pre><h2>🤔</h2><b>weak참조는 옵셔널 체이닝을 위한 코드 1줄만 들어가면 되는데 굳이 unowned가 있는 이유가 있을까</b>]]></content:encoded></item></channel></rss>